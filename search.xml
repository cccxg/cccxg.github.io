<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SOCKS 4/4A TCP代理协议</title>
      <link href="/2023/07/07/SOCKS-4-4A/"/>
      <url>/2023/07/07/SOCKS-4-4A/</url>
      
        <content type="html"><![CDATA[<p>参考:<br><a href="https://www.openssh.com/txt/socks4.protocol">SOCKS: A protocol for TCP proxy across firewalls</a><br><a href="https://www.openssh.com/txt/socks4a.protocol">SOCKS 4A: A Simple Extension to SOCKS 4 Protocol</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>SOCKS(Protocol for sessions traversal across firewall securely, 防火墙安全会话转换协议)是一种TCP会话转发协议, 最初由David Koblas提出, 后续由Ying-Da Lee修改并扩展到了第4个版本(SOCKS 4). SOCKS使得用户可以无感知地穿过防火墙访问外部目标应用服务器. 当每个客户端与SOCKS服务器的TCP会话开始时, 首先SOCKS服务器会进行访问控制, 随后SOCKS服务器仅需简单地在客户端与目标应用服务器间转发数据. 因为该协议独立于应用层的协议, 所以可以(已经)被许多不同的服务所使用, 如: telnet, ftp, finger, whois, gopher, www, 等等. 同时SOCKS 4也适用于程序使用加密来保护数据的情况. </p><p><strong>Note:</strong> 后续SOCKS服务器简称服务端, 目标应用服务器简称目标主机. </p><p>SOCKS 4的服务过程整体可以分为两个步骤:</p><ol><li><p>代理请求: 客户端建立与服务端的TCP连接, 并发送代理请求. 服务端可以根据请求的内容回复接受或者拒绝. 若接受请求, 则服务端建立一个到目标主机的TCP连接为后续数据转发做准备.</p></li><li><p>转发数据: 请求过程完成后, 服务端仅需简单地在客户端与目标主机之间转发数据即可.</p></li></ol><p>SOCKS 4请求的过程中定义了两种操作: <strong>CONNECT</strong>与<strong>BIND</strong>.</p><h2 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h2><p>CONNECT是SOCKS中最常用的操作, 适用于客户端仅需与目标主机建立一条TCP连接的情况. 当客户端希望与目标主机建立连接时, 客户端连接到SOCKS服务端并发送一个CONNECT代理请求. 请求数据包中包括目标主机的IP, 端口, 以及用户id等. CONNECT请求形式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">        +----+----+----+----+----+----+----+----+----+----+....+----+</span><br><span class="line">        | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|</span><br><span class="line">        +----+----+----+----+----+----+----+----+----+----+....+----+</span><br><span class="line">字节长度   1    1       2              4          可变长度         1</span><br><span class="line"></span><br><span class="line">其中: </span><br><span class="line">    - VN: SOCKS协议版本, 此处值应为4.</span><br><span class="line">    - CD: SOCKS操作码, CONNECT对应的值为1.</span><br><span class="line">    - DSTPORT: 目标主机端口.</span><br><span class="line">    - DSTIP: 目标主机IP.</span><br><span class="line">    - USERID: 用户id.</span><br><span class="line">    - NULL: 一个全0字节.</span><br></pre></td></tr></table></figure><p>服务端根据客户端IP, 目标主机IP, 目标主机端口, 用户id, 以及可能携带的认证信息(IDENT, 参见RFC 1413)来确定是否接受客户端CONNECT代理请求. 若接收请求, 服务端建立一个到目标主机指定端口的TCP连接. 当服务端到目标主机的连接建立成功, 或服务端拒绝了客户端请求, 或服务端操作失败(无法连接到目标)时, 服务端向客户端发送如下形式的回复:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">        +----+----+----+----+----+----+----+----+</span><br><span class="line">        | VN | CD | DSTPORT |      DSTIP        |</span><br><span class="line">        +----+----+----+----+----+----+----+----+</span><br><span class="line">字节长度   1    1       2              4</span><br><span class="line"></span><br><span class="line">其中:</span><br><span class="line">    - VN: 回复码版本, 此处值应为0.</span><br><span class="line">    - CD: 结果代码:</span><br><span class="line">        - 90: 请求准许;</span><br><span class="line">        - 91: 请求被拒或操作失败;</span><br><span class="line">        - 92: 请求被拒, 因为服务端无法连接到客户端的identd(参见RFC 1413);</span><br><span class="line">        - 93: 请求被拒, 因为客户端和identd(参见RFC 1413)报告了不一样的用户id.</span><br><span class="line">    - DSTPORT, DSTIP: 无实际意义, 仅是为了兼容性考虑(后文BIND操作的回复中有实际含义).</span><br></pre></td></tr></table></figure><p>当服务端操作失败或拒绝客户端代理请求时, 服务端向客户端发送回复消息后立即关闭它们之间的连接. 对于成功的请求, 服务端向客户端发送回复消息后立即开始进行双向数据转发. 这使得客户端可以在它到服务端的连接上进行I/O操作, 就好像它直接连接到了目标主机一样. </p><h2 id="BIND"><a href="#BIND" class="headerlink" title="BIND"></a>BIND</h2><p>BIND操作适用于客户端需要接受一个由目标主机发起的入站连接的情况. 入站连接的建立必须在客户端主动发起的到目标主机之间的主要连接已经建立之后. 这个过程通常是如下的一系列操作:</p><ol><li>客户端向目标主机建立主要连接;</li><li>客户端获取一个socket, 并获取该socket绑定的IP及端口;</li><li>客户端在socket上监听从目标主机发起的入站连接;</li><li>客户端通过主要连接通知目标主机socket绑定的IP及端口;</li><li>客户端接受目标主机发起的入站连接, 第二个连接建立成功.</li></ol><p>SOCKS BIND操作的目标就是支持上述的流程, 不同的是socket在服务端上, 而不是客户端.</p><p>BIND操作中客户端向服务端发送如下形式的代理请求:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        +----+----+----+----+----+----+----+----+----+----+....+----+</span><br><span class="line">        | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|</span><br><span class="line">        +----+----+----+----+----+----+----+----+----+----+....+----+</span><br><span class="line">字节长度   1    1       2              4          可变长度         1</span><br><span class="line"></span><br><span class="line">其中:</span><br><span class="line">    - VN: SOCKS协议版本号, 此处为4.</span><br><span class="line">    - CD: SOCKS操作码, BIND对应的值为2.</span><br><span class="line">    - DSTPORT, DSTIP: 目标应用服务端口, IP.</span><br><span class="line">    - USERIP: 用户id.</span><br><span class="line">    - NULL: 全0字节</span><br></pre></td></tr></table></figure><p>服务端根据上述代理请求信息, 以及客户端源IP等信息, 确认是否接受客户端的请求. 服务端对BIND请求的回复CONNECT请求回复形式一致:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">        +----+----+----+----+----+----+----+----+</span><br><span class="line">        | VN | CD | DSTPORT |      DSTIP        |</span><br><span class="line">        +----+----+----+----+----+----+----+----+</span><br><span class="line">字节长度   1    1       2              4</span><br><span class="line"></span><br><span class="line">其中:</span><br><span class="line">    - VN: 回复码版本, 此处值应为0.</span><br><span class="line">    - CD: 结果代码:</span><br><span class="line">        - 90: 请求准许;</span><br><span class="line">        - 91: 请求被拒或操作失败;</span><br><span class="line">        - 92: 请求被拒, 因为SOCKS服务端无法连接到客户端的identd(参见RFC 1413);</span><br><span class="line">        - 93: 请求被拒, 因为客户端和identd(参见RFC 1413)报告了不一样的用户id.</span><br></pre></td></tr></table></figure><p>与CONNECT代理请求的回复不同的是, 当一个BIND请求被接受时, 服务端的回复中的DSTIP, DSTPORT字段的值是有实际含义的. 在BIND操作下, 服务端将获取一个socket等待由目标主机发起的入站连接, 同时将该socket所绑定的IP及端口通过DSTIP, DSTPORT字段回复给客户端(第一次回复). 当DSTIP字段值为0时, 客户端需要使用它所连接的服务端的IP来替换该字段的值(当服务端不是一个多地址主机时将出现这种情况). </p><p>通常情况下(不使用代理时), 客户端程序可以通过函数调用直接获取socket绑定的IP及端口. 应用协议必须提供一个可以将这两个值从客户端发送到目标主机的方法, 从而使得目标主机可以主动发起并建立它们之间的连接. 当使用SOCKS代理时, 这个连接从目标主机连接到服务端而不是直接连接到客户端.</p><p>当从目标主机到服务端的连接建立成功后, 服务端再次向客户端发送回复(第二次回复). 服务端检查该连接的源IP与客户端BIND请求中的DSTIP是否一致. 若不一致, 第二个回复的CD字段设为91, 并且服务端关闭两端的连接. 若一致, CD字段设为90, 并且服务端开始在两个连接上转发流量. 随后对于客户端来说, 只需要对它到服务端的连接进行正常的I/O操作, 就好像它直接连接到了目标主机一样. </p><p>无论对于CONNECT还是BIND操作, 服务端都设置了一个与目标主机建立连接的时间限制(当前CSTC实现中设为2分钟). 若超时仍未建立与目标主机的连接, 则SOCKS服务端放弃连接并断开与客户端的连接.</p><h2 id="SOCKS-4A"><a href="#SOCKS-4A" class="headerlink" title="SOCKS 4A"></a>SOCKS 4A</h2><p>SOCKS 4A针对客户端无法进行域名解析的情况做了简单的扩展. </p><p>在SOCKS 4A中, 当客户端无法解析目标主机的IP地址时, 仅需将上文所述的代理请求数据包中的DSTIP字段的前三个字节设为0, 并将最后一个字节设为非0值, 对应IP 0.0.0.x, x不为0. 根据IANA(The Internet Assigned Numbers Authority, 互联网数字分配机构)的规定, 这样的地址是不允许作为IP地址的, 因此如果客户端可以解析域名, 就不应该出现. 请求数据包在NULL字节结尾之后, 客户端必须继续添加目标主机的域名并以另一个NULL字节结尾. 这同时适用于CONNECT和BIND操作. </p><p>当服务端使用SOCKS 4A协议时, 必须检查代理请求数据包中的DSTIP字段. 若对应的IP地址为0.0.0.x, x不为0, 则服务端必须读取请求数据包中携带的域名. 服务端应该解析域名并且建立到目标主机的连接. </p><p>服务端可能会传递它无法解析的域名给下一跳的SOCKS服务器.</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> SOCKS代理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/06/13/Hello-World/"/>
      <url>/2023/06/13/Hello-World/</url>
      
        <content type="html"><![CDATA[<h2 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h2><h3 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h3><p>Context:<br>Hello world.<br>Hello world.</p><p>Code</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Table</p><table><thead><tr><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>4</td></tr></tbody></table><p>Math<br>$$ y = \alpha * x^2 + \beta $$</p><p>List</p><ul><li>aaa</li><li>bbb</li><li>ccc<ul><li>ddd</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
